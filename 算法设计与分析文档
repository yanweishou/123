本次代码设计的伪代码（包括基本思路）：
MAX
Begin（算法开始）
输入 A，B
IF A>B 则 A→Max
否则 B→Max
返回 MAX
End （算法结束）
Beibao
Begin(算法开始)
录入物品个数n
依次录入每个条件对应的最大值b1,b2,b3,b4
依次录入一个物品对应的每个约束条件a1,a2,a3,a4
录入这个商品的价值p
ZeroOnePack函数处理
输出满足条件的最大价值
End(算法结束)
ZeroOnePack
Begin(算法开始)
四重循环
每重循环确定一个约束条件对应的最大值
调用MAX函数将满足的值调到约束条件对应的最大位置
END(算法结束)

调试过程中遇到的问题：
老师所给的约束条件有十个，但是在c++软件中，十个约束条件总是会报错，因此只讨论了四个约束条件的情况。

本次代码设计的分析：
在之前的01背包问题中，我们可以发现约束项都只有一个，下面我们来探讨两个约束项的情况；

首先，我们考虑使用一维还是二维来表达：在有一个约束项时，我们需要二维，因为横向表示物品数，而竖向表示约束项的改变；所以我们发现，当有两个约束项的时候，不能再使用二维数组的方式了；

所以，我们决定使用一维数组；再考虑，一维数组时，用数组的下标来表示约束项的改变，那么当有两个约束项的时候，明显下标不够，那么什么能用来表示两个约束项呢？

那就是二维数组。它包含的两个下标，正好分别对应了每个约束项；

所以，经过这样的思维流程，我们可以发现，其实含有两个约束项的二维数组实质上是由一维数组的表达算法衍化而来；

那么，我们在书写代码的时候，就要注意了，最大的循环应该依旧是物体的个数，因为不管怎样，都要遍历完所有的物品，即:

for(int k=1;k<=n;++k)

然后我们需要对两个约束项的0-m都进行遍历，即：

for(int i=m1;i>=0;--i)
for(int j=m2;j>=0;--j)

因为此方式是由一维数组的放大衍化而来的，所以遍历的时候，只能逆序遍历；

然后，我们应该考虑到，每次进行更新的时候，不能只对一个约束项进行控制，而是两个一起考虑，所以if条件应该修改为：

if(j>=a[k]&&i>=b[k])

而在更新的时候，同样应该进行两项的下标更新：

f[i][j]=max(f[i][j],f[i-b[k]][j-a[k]]+c[k]);


顺利执行代码后，输入物品数量、约束最大值（有四个）、依次分别输入6个物品的4个约束条件和价值，按回车键，就能得到最大价值了
